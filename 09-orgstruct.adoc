[#09-orgstruct]
= Organizational Structures

include::chapter-include.adoc[]

[quote, Douglas Adams, "The Restaurant At The End Of The Universe"]
If life is going to exist in a Universe of this size, then the one thing it cannot afford to have is a sense of proportion.

Organizations come in all shapes and sizes.
Unless your organization is extremely unusual, there is always some form of recognizable internal structure.
There may be the usual corporate divisions, departments and sections.
Or there may be dynamic teams, projects, work groups and task forces.
But some kind of _organizational structure_ is usually there.
And it matters.
While many organizational structures are quite far from the ideal, organizational structure is seldom completely useless.
Membership in some organizational units is a reason to automatically grant privileges.
Managers can usually access quite a wide set of data about employees in organizational units that they are managing.
Team leaders and project manager often exercise elevated privileges over their team and projects.
And all of that is not limited just to users.
Roles are often organized into _role catalog_.
Services and devices may be organized by applications, by geographical location and so on.
There are many things that need to be organized and there are many ways to to organize them.

Organizational structure affects almost every part of the identity management deployment.
We have realized that in very early stages of midPoint development.
Therefore organizational structure is an integral part of midPoint.
It permeates almost every part of midPoint functionality.
Unlike most other systems, organizational structure in midPoint is a very flexible and almost universal concept.
It can be used to build functional organizational structures with divisions, departments and sections.
But it can also be used to create a flat project-based organizational structure.
The same mechanism can be used to sort roles in a role catalog or to manage devices by geographical location.
And all of those organizational structures may co-exist at the same time in the same system.

The concept of organizational structure is a very powerful one, but it is implemented by just a handful of simple components.
Let us have a look at those building blocks now.

== Organizational Units

Basic building blog of all organizational structures is just one simple object type.
Due to the lack of poetic talent and because of critical shortage of abstract words in our dictionary, we have decided to call that object simply an _org_.
It is a nice and short name.
_Org_ can represent any kind of organizational unit: companies, division, department, section, project, team, role category, geographical location or anything else.
Orgs can be used to create hierarchical structures.
For example, a top-level org may represent a company. A couple of other orgs can represent divisions.
Those orgs can be put "inside" the company org.
Yet another orgs can represent divisions and they can be put "inside" the division orgs.
Repeat the process until complete organizational structure is formed.

image:09-01-org-tree.png[Organizational tree]

Org is quite a basic thing with a very simple anatomy:

.org-example-top.xml
[source,xml]
----
<org oid="4d12c1ac-440c-11ea-80af-2b314d06ba95">
    <name>F10000</name>
    <displayName>ExAmPLE, Inc.</displayName>
</org>
----

Strictly speaking, the only things that an org really needs are name and OID.
The example above adds `displayName` to make the presentation of the org nicer.
As all regular midPoint objects, a name of an org must be unique.
This often leads to a practice that org names are in fact identifiers or that they are generated automatically.
This is also our case.
We have decided to set `F1000` as the name of this org.
The value `1000` is an identifier of the company in our HR system.
As we are building a functional organizational structure of the company, we have prefixed the identifier with `F` which stands for _functional_.
However, names such as `F1000` are not very friendly.
Therefore there is a mechanism to set nicer display name that does not need to be unique.
The display name will be used instead of the ordinary `name` whenever this org is displayed to a user.

image:09-02-org-top.png[Top-level organizational unit]

We have an organizational unit now.
But how do we put users in it?
Clever reader already knows the answer: assignment.
All that is needed is to assign the org to a user.
This is done in almost the same way as you would assign a role, just select the `Org` tab in assignment dialog.

image:09-03-top-org-assignment.png[Assignment of an organizational unit]

Or, in XML form:

[source,xml]
----
<user>
    <name>eevans</name>
    ...
    <assignment>
        <targetRef oid="4d12c1ac-440c-11ea-80af-2b314d06ba95" type="OrgType"/>
    </assignment>
    ...
</user>
----


The user is a part of our minimalistic organizational unit now:

image:09-04-top-org-assignment-tree.png[Assigned top-level organizational unit]

== Organizational Structure Hierarchy

There is very little structure in our tiny organizational structure yet.
Orgs would not be very useful unless they can be placed inside each other, creating a hierarchy.
It is this hierarchy that makes organizational structures attractive.
Therefore let us go corporate and create some hierarchy now.
It is a well-known fact that all self-respecting corporations need sales and marketing division:

.org-sales-and-marketing-division.xml
[source,xml]
----
<org oid="7a1feb50-471f-11ea-8aab-1b2627541f15">
    <name>F11000</name>
    <description>Expensive people that make money.</description>
    <displayName>Sales and Marketing Division</displayName>
    <identifier>11000</identifier>
</org>
----

We have pimped up this organizational unit a little.
We have seen `name` and `displayName` before.
The `description` is no strange either.
But there is also an `identifier`.
The value of the `identifier` is usually an official "code" of the organizational unit assigned by HR people.
But why do we need yet another identifier?
OID is an identifier, `name` is an identifier of sorts, why do we need another one?
For now let's just say that the identifier will be very useful later on, when we will be synchronizing organizational structures.

If we import the org above into midPoint it will become the _top_ org.
MidPoint will put it at the same level as the ExAmPLE company org.
But we do not want that.
We want to create a hierarchy.
We want to tell midPoint to put the department inside the company.
How do we do that?
We use an assignment, of course:

.org-sales-and-marketing-division.xml
[source,xml]
----
<org oid="7a1feb50-471f-11ea-8aab-1b2627541f15"
    xmlns='http://midpoint.evolveum.com/xml/ns/public/common/common-3'
       xmlns:org='http://midpoint.evolveum.com/xml/ns/public/common/org-3'>
    <name>F11000</name>
    <description>Expensive people that make money.</description>
    <displayName>Sales and Marketing Division</displayName>
    <identifier>11000</identifier>
    <assignment>
       <targetRef oid="4d12c1ac-440c-11ea-80af-2b314d06ba95" type="OrgType"/>
    </assignment>
</org>
----

Now we have our little hierarchy:

image:09-05-small-org-tree.png[Small organizational structure tree]

This makes perfect sense, doesn't it?
User become part of organizational units when the units are assigned to them.
Therefore also organizational units become part of other organizational units when they are assigned to them.
And this applies to everything: roles, services, tasks, resources and other object types.
Every object type that can be _assignment holder_ can be placed in organizational structure.

.Assignment holders
NOTE: Majority of midPoint object types are _assginment holders_ and therefore they can be placed into organizational structure.
Theoretically.
However, midPoint user interface has some limits.
Convenient management of the assignments is currently possible only for _focal_ types: user, role, org and service.
Other objects can be placed in organizational structure and they should behave up to the expectations.
But that cannot be done by few convenient clicks in midPoint user interface
Not yet.
You have to use a different approach.
You either add the assignment manually in the XML/JSON/YAML form.
Or you may try to use mappings to create the assignments automatically.
Or perhaps use the REST interface to do that.
Or maybe send some money in the direction of midPoint development team to motivate them to add this functionality to user interface.

We know how to create a simple organizational hierarchy.
All we need to do now is to repeat the process _ad nauseam_ to create something that resembles real corporate organizational structure.
Let us add marketing department to our division:

.org-marketing-department.xml
[source,xml]
----
<org oid="a0c7d92c-4722-11ea-bc8d-d79a6cefb1bf"
    xmlns='http://midpoint.evolveum.com/xml/ns/public/common/common-3'
       xmlns:org='http://midpoint.evolveum.com/xml/ns/public/common/org-3'>
    <name>F11300</name>
    <description>Creative bunch that spends money to get more money.</description>
    <displayName>Marketing Department</displayName>
    <identifier>11300</identifier>
    <assignment>
       <targetRef oid="7a1feb50-471f-11ea-8aab-1b2627541f15" type="OrgType"/>
    </assignment>
</org>
----

It is the same process over and over again.
But there so many organizational units, there are so many files to import.
We like to be efficient in all the things that we do.
Therefore let's put the entire organizational structure into a single file:

.org-tree-functional.xml
[source,xml]
----
<objects>

    <!-- Functional organizational structure of ExAmPLE company -->

    <org oid="4d12c1ac-440c-11ea-80af-2b314d06ba95">
        <name>F10000</name>
        <displayName>ExAmPLE, Inc.</displayName>
    </org>

    <org oid="7a1feb50-471f-11ea-8aab-1b2627541f15">
        <name>F11000</name>
        <description>Expensive people that make money.</description>
        <displayName>Sales and Marketing Division</displayName>
        <identifier>11000</identifier>
        <assignment>
            <targetRef oid="4d12c1ac-440c-11ea-80af-2b314d06ba95" type="OrgType"/>
        </assignment>
    </org>

    ...

</objects>
----

It would be no big surprise to find out that laziness was a driving force behind many improvements in life, would it?
Now, let us use this convenient approach to create a nice and rich corporate organizational tree:

image:09-06-org-tree-page.png[Organizational tree]

TIP: Of course, you can create and manage organizational structure in midPoint user interface.
In fact, people do that quite often.
But now we are talking about the _initial_ organizational structure.
It is the structure that gets created in midPoint at the beginning of the deployment.
There is usually a lot of _trial and error_ until you get your midPoint configuration right.
It is quite likely you will have to purge all midPoint configuration and start clean.
In that case, it is very convenient to have organizational structure in one file that can be easily imported after the clean up.
Also, it is a common practice to have several environments: development, testing and production.
You probably want the same organizational structure in all of them.
Having organizational structure in a file makes that job easy.
Of course, you can also create organizational structure in the user interface and then export it into a file.
But according to our experience, many engineers prefer text editor to graphical user interfaces.

== Orgs in the Database

Organizational structures tend to form _hierarchies_ - data structures that look like trees.
But databases are usually designed to store _relational_ data - data structures that look like tables.
If you ever tried to express hierarchical data in a spreadsheet application you know that these paradigms are not entirely easy to align.
It is not entirely easy to express tree-like data structure in relational tables.
Moreover, hierarchical data tend to have some specific requirements.
For example, we usually want to look for people in _Operations Division_ and all the departments and sections that belong to it.
This is know as _subtree searches_, and it is usually not possible to execute them directly on data that are stored in relational form.

This is further complicated by the fact that midPoint _assignment_ is a very flexible data structure.
Assignments can be valid from a specific time to a specific time.
Assignments can be parametric and conditional.
Assignment is just too complex for the database to understand and use efficiently.

MidPoint is solving these problems with `parentOrgRef` operational data item.
As the name suggests, `parentOrgRef` is an object reference that points to _parent org_.
Any _assignment holder_ in midPoint can have _parentOrgRef_ and it points to the org (or orgs) that the object belongs to.
This somehow duplicated the data in the assignment.
But there are several crucial differences.

Firstly, `parentOrgRef` points to the orgs that the object is _currently_ member of.
I.e. it only reflects those assignments that are currently active and valid.
Therefore there will be no `parentOrgRef` value for assignment that is expired or not valid yet.

Secondly, `parentOrgRef` represents all organizational assignments, both direct and indirect.
Orgs that are directly assigned to users will be present in `parentOrgRef`.
Orgs that are induced in a role that is assigned to the user will also be present in `parentOrgRef`.
Everything will be there.

Thirdly, `parentOrgRef` is a very simple data structure.
This simplicity allows efficient _indexing_ of the `parentOrgRef` values in the database (repository) layer.
The indexes are designed to allow efficient subtree searches over organizational structure hierarchies.

This is our trick how to fit hierarchical data into flat data tables.
The details may be quite complicated, but it usually works quite well.
The `parentOrgRef` is automatically maintained by midPoint under the hood.
Therefore it is usually completely transparent.
The user does not even notice that there is a special mechanism working in the background.

However, there are also downsides to this approach.
The index that is build on `parentOrgRef` is designed to work even if organizational structure is re-organized.
The index has to be continually maintained.
Maintenance overhead of the index is usually very low for small or mid-sized structures that do not change often.
But maintenance of massive organizational structures can be painful.
Similarly, it may be problematic to maintain organizational structures that change very frequently.
Therefore it is perhaps a good idea to prototype the design of organizational structure before putting the system into production.
Also, the `parentOrgRef` is in fact a copy of the primary data (assignment).
As it is a copy, there is a risk that it may get out of synchronization.
MidPoint is designed to keep `parentOrgRef` and all the indexes strictly consistent during normal operations.
However, midPoint allows systems administrators to do a lot of non-standard things.
Some of those things may lead to data inconsistencies.
Therefore it is a good idea to check whether the values of `parentOrgRef` make sense in case you notice that organizational structures are behaving strangely.

Overall, organizational structures work very well in midPoint and you usually do not need to care about the mechanisms under the hood.
However, management of organizational structures is much more complex than it seems.
Therefore if you try to do strange and unusual things, you should better be sure you fully understand what you are doing.

== Orgs and Roles

Organizations and roles have many things in common.
Roles are granting privileges to its members.
Usually, people that are members of an organization are granted privileges too.
People that have the same role usually have the same set of privileges.
People in an organization often have the same privileges too.
In fact, organizations behave in almost the same way as roles.

MidPoint has fully embraced this similarity.
Orgs are designed to behave in almost the same way as roles.
Orgs may have _inducements_, there may be _constructions_ in them, orgs may contain _authorizations_ and so on.
Org can do everything that a role can do.

Therefore there is no need to set up complicated configurations that assign a particular role to all members of an organization.
The organization itself acts as a role.
All the privileges that organization members need can be simply added as _inducements_ in the organization itself.
This is very simple, elegant and mostly fool-proof solution.

We have _Indirect Sales Department_ in ExAmPLE, Inc.
We want to make things simple, and therefore we want to grant access to CRM system to all the members of this department.
It is very easy to do:

[source,xml]
----
<org oid="8887e0b0-4726-11ea-96b0-5f5ced221e42">
    <name>F11200</name>
    <description>Suits that talk to other suits that talk to customers.</description>
    <displayName>Indirect Sales Department</displayName>
    <identifier>11200</identifier>
    <assignment>
        <!-- Assignment of parent organizational unit -->
        <targetRef oid="7a1feb50-471f-11ea-8aab-1b2627541f15" type="OrgType"/>
    </assignment>
    <inducement>
        <!-- Inducement that grants CRM privileges to all members of this department -->
        <construction>
            <!-- CRM resource -->
            <resourceRef oid="04afeda6-394b-11e6-8cbe-abf7ff430056"/>
            ...
        </construction>
    </inducement>
</org>
----

Clever reader certainly wonders whether the CRM privileges apply also to _Agent Management Section_, which is located below _Indirect Sales Department_ in our organizational structure.
However, clever reader is clever enough to figure out that the privileges are not "inherited" in this case.
To follow the toughts of clever reader, you have to think about orgs in the same way as you would think about roles.
There is an assignment from _Agent Management Section_ to _Indirect Sales Department_.
But there is no _inducement_.
Role hierarchies are built using _inducements_.
Therefore privileges of _Agent Management Section_ are not included in _Indirect Sales Department_.
This may seem to be counter-intuitive, but in fact it is completely correct.
Orgs and roles form separate hierarchies (see note below).
However, if you want to "inherit" privileges of a parent org, there is a very simple way how to do it: add explicit _inducement_.
For example, this is how we can "inherit" the CRM privileges in _Agent Management Section_:

[source,xml]
----
<org oid="f5e619a6-4726-11ea-888c-ab25c098d8b3">
    <name>F11210</name>
    <description>People that deal with agents (no James Bond here).</description>
    <displayName>Agent Management Section</displayName>
    <identifier>11210</identifier>
    <assignment>
        <!-- Assignment of parent organizational unit. This creates organizational hierarchy. -->
        <targetRef oid="8887e0b0-4726-11ea-96b0-5f5ced221e42" type="OrgType"/>
    </assignment>
    <inducement>
        <!-- Inducement to parent organizational unit. This creates "inheritance" of privileges. -->
        <targetRef oid="8887e0b0-4726-11ea-96b0-5f5ced221e42" type="OrgType"/>
    </assignment>
</org>
----

This has to be done for every org that needs to inherit privileges from parent, which may be quite daunting for large organizational structures.
There is a clever way how to avoid placing inducements everywhere.
The solution involves the concept of _metaroles_, as parent org is technically a metarole for child orgs.
However, this involves an advanced thinking about application of assignment and inducements.
Even a clever reader may not be ready for such abstract thoughts yet.
This has to come later when the basic principles have enough time to sink in.

.Org and role hierarchies
NOTE: Both orgs are roles are _hierarchical_ in a way.
BUt it is not the same hierarchy.
Org hierarchy is used to model organizational trees.
Role hierarchy is used to build RBAC structures.
Those hierarchies have completely different purpose.
They are also built using different mechanism.
Role hierarchy is used to group privileges and therefore it is built using _inducements_.
Org hierarchy is used to group subjects (users) and it is built using _assignments_.
There are also different internal mechanisms, indexing and data storage properties.
For example, role hierarchy is not using `parentOrgRef`, therefore there is much lower overhead as compared to org hierarchy.
However, this means that the capabilities to query role hierarchy is limited.
Both hierarchies are their respective place and purpose.
Even though the difference may not be very apparent now, it is quite substantial.
Hopefully, this will get much more clear later when there will be more examples for both org and role structures.

== Managers

Placing people in organizational structures has a significant value on its own.
However, all the people usually do not have the same _relation_ to the organizational unit.
Most people will usually be ordinary _members_ of organizational unit.
And then there are people that are somehow special: departmental managers, team leaders, project managers, supervisors and similar life forms.

How do we designate a manager of an organizational unit?
You probably guessed it already.
In a typical midPoint fashion, we are re-using _assignment_, of course.
There is just one small detail.
We are specifying `relation` in assignment target reference:

[source,xml]
----
<user>
    <name>aanderson</name>
    ...
    <assignment>
        <!-- Direct Sales Department -->
        <targetRef oid="832f409a-4726-11ea-b0be-8b8eab99c1ed" type="OrgType" relation="manager"/>
    </assignment>
    ...
</user>
----

This assignment makes Alice a manager of direct sales department.
It is as simple as that.
And all the power of assignment is at your disposal.
Therefore it is easy to assign a manager for a temporary time period, suspend a manager and so on.

Manager assignment is created in the user interface in almost the same way as normal assignment is created.
The only difference is selection of _manager relation_ at the bottom of the assignment target dialog:

image:09-07-assign-org-manager.png[Assign organizational unit manager]

MidPoint now knows that Alice is a manager of Direct Sales Department.
This is also displayed in the organizational tree:

image:09-08-org-tree-manager.png[Organizational unit with a manager]

But, wait a minute!
Alice has been promoted to be a _manager_ direct sales department.
But she should be located in sales and marketing division as a direct _member_ of that division.
E.i. she is _member_ of one organizational unit and _manager_ of another organizational unit.
How do we do that?
This is all perfectly clear to a clever reader by now.
Alice has assignments.
First assignment is an ordinary assignment that targets sales and marketing division.
Second assignment is a manager assignment that targets direct sales department.
This is perfectly normal in midPoint.
Users may have any number of assignments to any objects (unless it is explicitly constrained by policy rules or archetypes).
Which means that users may be members of any number of organizational units at the same time.

Therefore there is no problem for Alice to be a member of one unit and manager of another.
MidPoint can support all kind of bizarre organizational arrangements.
MidPoint was deliberately designed in this way.
Because reality has an annoying habit to bring surprises, especially when organizational structures are involved.

Well, Alice is a manager now.
Good for her.
But she still has the same access rights as ordinary workers.
That is not right!
Managers wear suits and ties.
Which means that they need to have more privileges than mere mortals.
As managers usually control funding of software development, it is perfectly understandable that midPoint has a way to set up privileges that apply to managers:

[source,xml]
----
<org oid="832f409a-4726-11ea-b0be-8b8eab99c1ed">
    <name>F11100</name>
    <displayName>Direct Sales Department</displayName>
    ...
    <inducement>
        <construction>
            ... Privileges exclusive to managers are specified here ...
        </construction>
        <orderConstraint>
            <order>1</order>
            <relation>manager</relation>
        </orderConstraint>
    </inducement>
</org>
----

This is a way how a manager of the direct sales department gets special privileges.
The `orderConstraint` makes sure that only the users that have `manager` relation to this organization units will get the privileges.

But wait s minute!
Clever reader does not like that.
This approach to manager privileges is not going to be very practical.
Managers usually do not have special privileges in each organizational unit.
In most organizations, managers have the same privileges regardless of the unit they manage.

One way to implement this approach is to create a `Manager` role, put the special privileges there, and assign the role to every manager of every organizational unit.
But that creates redundancy.
We have to make sure this role is assigned whenever a person becomes manager and that it is unassigned when the person is no longer manager.
This is the way how this problem is solved in many IDM deployments.
But it is quite a fragile mechanism.
And this is not a way how we do things in midPoint.

The `orderConstraint` data structure in our example looks suspiciously complex.
And it indeed is quite a complex concept.
What we see here is the first glimpse at high-order "assignment algebra" that is a working horse of complex midPoint deployment.
It is often employed when working with meta-roles and archetypes.
As organizational units are in fact roles and organizational structures are just a trees formed by _assignments_, they technically form meta-role structures.

Therefore the right way how to set up manager privileges is to move privilege definition to a central place.
It may be top-level organizational unit, or it may be an _archetype_.
In that case our _inducement_ can apply to all the managers, regardless of organizational unit.
However, the exact configuration is a bit complex, and we still need to learn more about midPoint to be able to use it.
Therefore we leave the details for later chapters.

TIP: MidPoint assigns managers to organizational units.
That is the right way how to do it.
However, we have often seen a different approach.
In such cases the manager is "assigned" to users.
I.e. each user has a reference to his or her manager.
This approach is wrong.
Organizational structures change.
People come and go.
Everything is changing all the time.
It is very easy to change one assignment in organizational structure in case that a manager is replaced.
But it is extremely difficult to replace a manager in the direct user-manager data structure.
Maybe the former manager was managing several organizational units and now we are replacing him with two managers.
Maybe there is a re-organization going on at the same time.
The result is going to be a mess.
Avoid the direct user-manager approach whenever possible.

== Relation

In midPoint, we like to design generic re-usable mechanisms.
You did not think that we made the concept of _manager_ in a way that would be hardcoded to organizational structure, did you?
As you have got so far through this book, you would probably suspect there is more to this _relation_ thing that we have seen so far.

The _relation_ specifies the nature of a relation between two objects.
For example a user may be a member of an organizational unit, manager of a project, owner of a role or approver of role assignment requests.
In such cases, _member_, _manager_, _owner_ and _approver_ are relations that a user can have to an object.

The most common way how to use relation is to specify it in `targetRef` in an assignment.
The following example illustrates the usual way how to assign an owner for a role:

[source,xml]
----
<user>
    <name>aanderson</name>
    ...
    <assignment>
        <!-- Business Analyst role -->
        <targetRef oid="aaa6cde4-0471-11e9-9b50-c743da469067" type="RoleType" relation="owner"/>
    </assignment>
    ...
</user>
----

There are several built-in relations in midPoint:

|===
|Relation |Usually used for |Description

|`default`
| Everything
| This is the most common, non-specific relation to an object.
When used with a role, it simply means that the user _has_ the role.
Usually interpreted as _member_ when used with organizational units.
It is the usual, normal relation.

As the name suggests, this is the default relation.
If no other relation is specified, this relation is used.

|`manager`
|Orgs
|Manager of an organizational unit, project manager, teamleader, etc.
Usually entitles a person (or a group) that have leading position in an org.
This usually specifies executive or operational privileges (cf. `owner`).

|`owner`
|Roles, Orgs
|Person responsible for governance of the object.
Often used to nominate role owners that are responsible for role definition and maintenance.
May be used with organizational units to specify project sponsor or business owner.
Specifies a person responsible for governance and high-level policy decisions rather than day-to-day management (cf. `manager`).

|`approver`
|Roles, Orgs
|Person responsible for deciding _membership_ in roles and orgs.
A gatekeeper or moderator.
Approvers usually decide whether someone can have a role, or may be a member of organizational unit.
Unlike owners, approvers do not create or modify role definition.
They cannot change the role.
They can only decide who can have that role and who cannot.

|`meta`
|Metaroles
|Special-purpose relation that is sometimes used with metaroles.
Metarole structures can be complex and confusing.
However, such structures and especially policies that govern them may sometimes be simplified, if role-metarole relations are marked in a special way.
This relation is designed specifically for that purpose.

The `meta` relation is not mandatory.
Metarole functionality will work just fine without it.
In fact, almost all of the metarole configuration are not using this relation.
But it may come handy if the situation becomes too complicated.
|===

Those are built-in relations.
There are some pre-configured policies that work with them.
However, you are free to specify and use your own relations.
But that is quite an advanced topic and majority of the deployments are perfectly fine using just the built-in relations.

As you can see, the built-in relations do not have overly strict specifications.
There is a lot of _usually_, _often_ and _almost_ in the description of relations.
The reason is that the relations do not do anything just by themselves.
They just specify how one object relates to another object.
There are no strict _policies_ or _behavior_ associated with them.

The policies are specified elsewhere.
Assignment and inducements may behave differently for different relations, as we have seen in previous section.
Similarly, _policy rules_ are often sensitive to relations.
For example the policy that assignment of some roles has to be approved is implemented by a policy rule that is aware of `approver` relation.
Authorizations are often sensitive to relations.
Archetypes influence how the system behaves based on relations.
User interface may behave differently for some relations.
And so on.
Relations do nothing just by themselves.
However, good part of the system is usually configured to recognize relations and behave accordingly.
It is a matter of that _configuration_ that determines how exactly will the system behave.
This is also the reason for such vague definition of relations, even those built-in relations.
They will do what you make them do.

== Multiple Organizational Structures

Tree is a simple and very elegant structure in many ways.
But it is a rare sight to see a lone tree growing in the field.
When we think of trees, we usually think about a forrest.
It takes a lot of trees to make a forrest.

This is also the case when it comes to organizational structures.
It is a very rare sight when an entire organizational structure of an organization can be modeled in a single tree.
There is always the usual _functional_ organizational structure with divisions, departments, sections, companies, branches, schools and faculties.
But then there is a _project_ organizational structure that is often completely orthogonal to functional organizational structure.
This is sometimes spiced up with workgroups, task forces, focus groups, research teams, interest groups, clubs and similar collective life forms.
There are the many trees that make a forrest.

Fortunately, midPoint is not very picky when it comes to organizational structures.
You can have as many organizational trees as you like.
MidPoint is not limited to a single organizational tree.
You can have functional organizational tree, as we have seen in previous sections.
Then you can have independent project organizational structure.
Just create new root _org_ for projects and place the projects under it:

.org-tree-project.xml
[source,xml]
----
<org oid="832e37e4-edfd-11ea-9f8c-ef736d6646a2">
    <name>Projects</name>
</org>

<org oid="9c1b8464-edfd-11ea-87b8-db467c5ae301">
    <name>PBD2020</name>
    <description>Make money fast.</description>
    <displayName>Big Deal</displayName>
    <identifier>BD2020</identifier>
    <assignment>
        <targetRef oid="832e37e4-edfd-11ea-9f8c-ef736d6646a2" type="OrgType"/>
    </assignment>
</org>

<org oid="22dc2bd4-edfe-11ea-a904-5be54dda2e46">
    <name>PLS</name>
    <description>Make sure our marketing message gets across.</description>
    <displayName>Loudspeaker</displayName>
    <identifier>LS</identifier>
    <assignment>
        <targetRef oid="832e37e4-edfd-11ea-9f8c-ef736d6646a2" type="OrgType"/>
    </assignment>
</org>

<org oid="1954d496-f6ad-11ea-a96a-8bfa569f5fff">
    <name>PWL2</name>
    <description>Second generation wonderland. We are all mad here.</description>
    <displayName>Wonderland 2.0</displayName>
    <identifier>WL2</identifier>
    <assignment>
        <targetRef oid="832e37e4-edfd-11ea-9f8c-ef736d6646a2" type="OrgType"/>
    </assignment>
</org>
----

We have two organizational trees now.
Each neatly stowed under its own tab:

image:09-09-org-tree-projects.png[Project organizational tree]

This is a nice _project_ organizational structure.
But our users are members of _functional_ organizational structure already.
How can I add my users to the projects?
The answer is _assignment_, of course.
User can belong to any number of organizational units at the same time.
It makes no difference whether they are in the same organizational tree or in different trees.
Simply assign the projects to the users.
The same _manager_ relation works for projects as well.
In fact, midPoint does not even recognize the difference between _functional_ and _project_ organizational structures.
They look all the same to midPoint and midPoint treats them in the same way.
If there is a need for the structures to behave differently, it has to be explicitly configured.
Which is usually done by using _archetypes_.
We will talk about _archetypes_ later.

There are two organizational structures now.
You can have three organizational structures if you want to.
Of five of them.
Any number you like - as long as all the tabs for organizational structures fit on the screen.
The structures can be deep and trees with many branches.
Or they can be completely flat.
The structure may not even be a tree.
As long as it is an _acyclic directed graph_ it will work just fine.
It can have multiple roots, it may have alternate paths, it can do all the crazy stuff.
Just avoid cycles.
Cycles break the maths which is the foundation of organizational structure indexing and evaluation.
Cycles won't work.
But pretty much all the other arrangements are perfectly fine.

Organizational structure may have almost any form.
A user can be a member of many organizational units.
Which also means that a user may _manage_ many organizational units.
That also applies the other way around: an organizational unit may have many managers.
MidPoint fully supports all such cases.
By default, MidPoint is very flexible when it deals with organizational structure.
However, you may not like all this liberalism in organizational management.
_Ordnung muss sien!_
If you want to constraint organizational management to allow only a single manager for each organizational unit, you can do it.
But you have to explicitly specify a policy by setting up _policy rules_.
_Policy rules_ provide a very generic and very powerful mechanism how to constraint and control midPoint in many ways.
But that is a topic for its own chapter.

== Role Catalog

MidPoint organizational structure can do a lot of crazy stuff.
By now, you should not be too surprised to learn that we are not done yet.
Organizational structures are usually build to contain people.
Whereas midPoint organizational structure can contain a broad range of object types.

_Role catalog_ is a common use of organizational structure that does not (directly) involve people.
Role catalog is used to sort the roles into categories, much like a catalog in electronic shop is used to sort the products.
The catalog is used to present roles to users in organized form, so users may easily find the roles when request them in self-service interface.

MidPoint role catalog is simply an organizational structure.
It does not have divisions, sections or projects, but it has categories.
Yet the mechanism is the same, as the catalog is just a hierarchy of orgs:

TODO: Catalog XML example

It makes a lot of sense to use organizational structure for role catalog.
Simple explanation would go along the lines of _roles are people too_.
Roles have many characteristics that users have.
Roles also need to be managed, they need to sorted, categorized, they have owners and approvers.
Role management is often divided in several teams or application owners.
Many of the mechanisms that are used to manage people are also used to manage roles.

TODO: authorizations, delegated administration
TODO: categories may represent applications, approvals for role modification by application owner (rules)

TODO: mention role catalog in RBAC section

== Organizational Structure Synchronization

TODO: generic synchronization
TODO: kind/intent
TODO: focus-projection (terminology)
TODO: automatic assignment of org in inbound mapping
TODO: simple principles (e.g. roles) reused everytwhere

TODO: reason of having `identifier` in org:
* easier correlation
* identifier does not need to be unique among org trees, name needs to be unique.

== Conclusion

TODO: orgstruct used for certifications
TODO: delgated administration