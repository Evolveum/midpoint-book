[#07-rbac]
= Role-Based Access Control

include::chapter-include.adoc[]

[quote, Mentat conundrum, "Dune: House Corrino by Brian Herbert"]
Simplicity is the most complex of all concepts.

Basic idea of Role-based access control (RBAC) is very simple: instead of assigning the same privileges to users over and over again, let’s group such privileges into roles.
Then assign roles to users.
This often aligns with organizational roles such as _manager_, _assistant_ or _analyst_.
Therefore roles are quite easy to understand even on an intuitive level.
And RBAC should make your life easier - at least in theory.

Role-based access control principles are present in almost all identity management systems.
Therefore it is no surprise that RBAC is one of the basic midPoint mechanisms to organize privileges in midPoint.
MidPoint supports all the usual RBAC features such as role hierarchies, an automatic assignment of roles, entitlement definition etc.
But midPoint goes beyond traditional RBAC. MidPoint roles can be smart.
There may be dynamic expression inside midPoint roles, such as attribute mappings.
The roles may be conditional, so one role is included in another role, but only in case that a specific condition is satisfied.
The roles may be parametric, so the role can determine the specific set of entitlements based on the user data or a parameter of a role assignment.

But midPoint role dynamics goes even one step further.
The RBAC system can be applied to the roles themselves, thus creating _meta-roles_.
It is quite common that the roles are divided into several types: application roles, business roles, technical roles and so on.
However, all the business roles have common characteristics such as common approval processes, common life-cycle policies etc.
Instead of copying the common parts into each and every business role, the business roles may be assigned a common meta-role.
The meta-role defines all the common characteristics of all business roles, therefore the RBAC system is much easier to maintain.
And this concept is extended even further with _archetypes_.
But more on that later.

NOTE: The term _RBAC_ is many things to many people.
We use the term _RBAC_ in quite a broad sense.
We do not strictly mean NIST RBAC model.
What me mean by _RBAC_ is a generic mechanism that is based on the concept of roles.
Although the basic principles of midPoint RBAC are very similar to NIST RBAC model, we take the liberty to deviate from NIST model when needed.
And as you will see later, such deviation is really necessary.

== Reality, Policy and Assignments

Previous chapters were focused on account provisioning and synchronization.
Which means that the primary focus was an _account_ (or a similar resource object).
This is what we call _reality_ in midPoint way of thinking.
Accounts are objects that exist in the databases and files on the resources.
In that aspect they are almost tangible things.
Existence of an account allows user to access a particular system, to execute operations and so on.
Therefore we consider an account to be something _real_.

But how do we know whether an account should exist or it should not exist?
The situation would be quite clear if midPoint is the only source of truth.
In that case if there is a linked shadow then account should exist.
If there is no shadow then account is illegal.
But reality is almost never that simple.
In real deployments MidPoint is not the only source of truth.
It is usually human resource (HR) system that is the source of the truth – but only for some types of users, usually employees.
Then there are external users, temporary workers, special personas for user administrators and so on.
Some of them may have their own source systems similar to HR database.
But for some users it may still be midPoint which is the ultimate source of truth.
And that “truth” may be in fact only partial or compiled from several sources.
To keep a long story short: reality is messy and complicated.
And it is often quite difficult to figure out which accounts particular user should have and which he should not have.
Yet, for an IDM system this distinction is absolutely crucial.
Various IDM systems came with broad range of mechanisms to handle this problem, and sadly, those mechanisms are often not very good.
Fortunately, midPoint was designed from the beginning with a full awareness of this problem.
Therefore there is a clean distinction between _reality_ and _policy_ in midPoint.

Accounts, shadows and links are what we refer to as _reality_.
Those describe what _exists_, what _is_.
And there is a separate mechanism to describe policy.
Policy, in midPoint parlance, means definition of what _should be_.
In the ideal world _reality_ and _policy_ should be in accord.
They should describe the same state of things.
But we do not live in ideal world.
Perfectly good accounts may be deleted by mistake, illegal accounts may be created, entitlements may get mixed up, attribute values destroyed – there are many dangers in the big wild world out there.
And then there are scenarios when we actually want reality to be different than policy for some period of time.
Those may be migration scenarios when a new system is being connected to midPoint and the data needs to be cleaned up.
_Reality_ and _policy_ do not match exactly in practice.
We all know that only too well.
Therefore midPoint is designed in such a way that it can graciously handle the differences between _reality_ and _policy_.

When it comes to policy, the most important concept is an _assignment_.
Simply speaking, assignment is a data structure which specifies that a particular user should have something.
The simplest case is _account assignment_.
This type of assignment states that the user should have an account on a particular resource.
When such an assignment is added to a user, there is suddenly a discrepancy between reality and policy.
The assignment states that a user _should have_ an account.
But there is no such account yet.
It is a nature of midPoint to align policy and reality as much as possible (unless it is told otherwise).
Therefore midPoint will try to create missing account.
Once that account is created _reality_ and _policy_ are aligned once again.

The mechanism that midPoint uses to define that a particular user needs an account, entitlement or other resource object is called _construction_.
The simplest case is a _construction_ that specifies to create an account (a.k.a _account construction_):

[source,xml]
----
<user>
    ...
    <assignment>
        <construction>
             <resourceRef oid="8a83b1a4-be18-11e6-ae84-7301fdab1d7c"/>
             <kind>account</kind>
        </construction>
    </assignment>
    ...
</user>
----

The term _construction_ means that object on that particular resource should be constructed.
In this case the object on OpenLDAP resource should be constructed for this particular user.
If no construction parameters are specified then a _default account_ will be constructed.
Which means that outbound mappings in the OpenLDAP resource definition will be used to set up the account.

image::07-01-user-assignment-resource-simple.png[Simple account assignment]

Construction can be quite a complex data structure describing object types, object classes, attributes and so on.
However,it is unlikely that they will be placed directly in assignment like this.
But more on that later.
What is important for now is that assignments specify _policy_.

After the assignment is added to a user and all the processing and provisioning takes place the situation looks like this:

image::07-02-user-assignment-resource-account.png[Simple account assignment and account link]

Assignment is a definition of policy which states that an OpenLDAP account should exist for Alice.
But there is no such account.
Therefore MidPoint aligns reality an policy by creating that account.
As for any other account there is a shadow and a link to track account ownership.

This may look like a very complicated method to do something simple.
But this kind of thinking is really necessary to handle complex cases.
There may be several assignments that mandate the same account.
There may be assignments for the same accounts, but each assignment mandates different attributes or values.
The account that the assignments mandate may exist already, e.g. it may be linked by previous reconciliation with the resource.
There may be several accounts for the same user on the same resource (e.g. “ordinary” account and “testing” account).
And so on.
We will deal with various cases in this book.
But the basic principle is the same: assignments are policy and midPoint is trying to align reality to match the policy.

== Roles

There is much more in the concept of an assignment than just the very simple account assignment that was introduced above.
Assignment is a generic mechanism that is used in midPoint for wide variety of cases, from simple account provisioning to really complex identity governance policies.
But one specific assignment type is particularly interesting with respect to the topic of this chapter: role assignment.

The basic idea of Role-Based Access Control (RBAC) is simple:
Instead of assigning account to users directly, let us group all accounts that a particular group of users need into a _role_.
Then assign the role to users.
Later on you may add new application to your system and you want all the users to have account there.
In that case all that is needed is to add that account to a role and recompute the users.
All the users that should have the account will get the account.
This principle is reused for may purposes in midPoint: accounts, privileges, authorizations, policies ...

Role is a special type of object in midPoint.
But as all midPoint objects it has a very familiar structure:

[source,xml]
----
<role oid="aaa6cde4-0471-11e9-9b50-c743da469067">
    <name>Business Analyst</name>
    ...
</user>
----

Role object has its OID and name.
The rest of the role usually specifies the privileges that the role gives to the users.
But how do we give this roles to users?
That is what role assignment is good for:

[source,xml]
----
<user>
    <name>alice</name>
    ...
    <assignment>
        <targetRef oid="aaa6cde4-0471-11e9-9b50-c743da469067" type="RoleType"/>
    </assignment>
</user>
----

User `alice` has role `Business Analyst` assigned.
The assignment is using the familiar style of object references in midPoint, referring to the role by its OID.
This is very useful, as the assignment stays the same in case that the role or the user are renamed - and both of those events are much more frequent that one would think.

== Provisioning Roles

Provisioning is the bread and butter of identity management.
Therefore it is quite understandable that the most natural usage of roles in midPoint is to automate provisioning.
Provisioning roles are usually combining several _construction_ statements.
The idea is that a provisioning role should specify all the privileges that users of that role need.
Therefore a `Business Analyst` role may look like this:

[source,xml]
----
<role oid="aaa6cde4-0471-11e9-9b50-c743da469067">
    <name>Business Analyst</name>
    <inducement>
        <construction>
             <!-- OpenLDAP resource -->
             <resourceRef oid="8a83b1a4-be18-11e6-ae84-7301fdab1d7c"/>
             <kind>account</kind>
        </construction>
    </inducement>
    <inducement>
        <construction>
             <!-- CRM resource -->
             <resourceRef oid="04afeda6-394b-11e6-8cbe-abf7ff430056"/>
             <kind>account</kind>
        </construction>
    </inducement>
</user>
----

The usual case is that every employee need to have basic access to company functionality.
In our case that access is granted by an account in central OpenLDAP directory.
In addition to the basic LDAP account, business analysts need access to the CRM system.
The role combines all the accounts that a business analyst needs.
Assign that one role and the user has all that is needed to do the job.

But, what is that mysterious _inducement_ thing?
Think of inducement as indirect assignment.
Assignments give privileges directly to the object in which they are placed.
The assignment in the previous section gave account to the user because it was placed in the user object.
However, here we do not want the accounts to be created for a role.
We want accounts to be created for all the users that have the role.
That is one _order of indirection_ down the line.
Therefore we (usually) do not want to use assignments in roles.
We want to use something that reflects this indirect relation.
And that is exactly what inducement is.
Inducement is very similar to assignment - in fact it has exactly the same structure.
But while assignment is direct, inducement is indirect.

image::07-03-user-assignment-role.png["User, role and resource"]

MidPoint user interface can show a nice summary of the inducements:

image::07-04-gui-role-inducements.png[Role inducements in user interface]

It is perhaps worth explaining what happens if this `Business Analyst` role is assigned to a user.
When that roles is assigned to a user, midPoint will process all the parts of role definition.
MidPoint will take the inducements from the role and apply them to the user.
In fact, midPoint will behave in almost the same way as if those construction statements were specified directly in user’s assignment.
And then we have the familiar principle: policy mandates that two accounts should exit, but in reality there are no such accounts.
Therefore midPoint creates the accounts.
MidPoint also creates appropriate shadow objects and links them to the user.

image::07-05-user-assignment-role-accounts.png["User, role assignment, shadows and accounts"]

Many applications implement at least some aspects of RBAC, as RBAC is a very useful way how to organize the privileges.
However, almost all the applications limit the applicability of RBAC to the application itself. I.e. roles in an application can contain only those privileges that apply to that particular application.
The roles cannot have privileges from other application.
But IDM systems are different.
IDM systems such as midPoint are reaching out to many applications (resources).
Therefore a single midPoint role can give access to many applications at once.
No other application can do that.

== Roles, Accounts and Attributes

We have already seen how outbound mappings can be used to set up account attributes.
Roles can also contain outbound mappings, therefore they can be used for a similar purpose:

[source,xml]
----
<role oid="aaa6cde4-0471-11e9-9b50-c743da469067">
    <name>Business Analyst</name>
    <inducement>
        <construction>
             <!-- OpenLDAP resource -->
             <resourceRef oid="8a83b1a4-be18-11e6-ae84-7301fdab1d7c"/>
             <kind>account</kind>
             <attribute>
                 <ref>ri:title</ref>
                 <outbound>
                     <expression>
                         <value>Business Analyst</value>
                     </expression>
                 </outbound>
             </attribute>
        </construction>
    </inducement>
    ...
</role>
----

When the above role is assigned to a user, an account on OpenLDAP server will be created.
The account will be provisioned in an usual way.
All the outbound mappings from resource definition will be applied to set up the account.
But there is one difference.
The role specifies one additional outbound mapping for the account.
This mapping will be included in the set of usual account mappings when the account will be provisioned.
Therefore the account will have attribute `title` set to `Business Analyst`.

This is a very typical way how midPoint deployments are set up:

* Common and usual attribute values are specified by outbound mappings in the resource definition (in `schemaHandling`).
Those are usual mappings that take user properties as their source.
Many of those mappings do not even modify the value at all (`asIs` mappings).

* Attributes that are specific to roles are defined in the roles themselves.
Those mappings often do not have any source at all.
They just set a static value (literal `value` mappings).

At the time when midPoint is about to provision an account, all the mappings are merged and processed together.
It is quite common than more than one role has a construction for the same account.
All those constructions from all such roles are merged together and they are added to the mappings specified in resource definition.
All those mappings are used to compute final values of account attributes.

Most account attributes are single-valued.
Attempt to set more than one value for such an attribute will end up with an error.
Therefore it does not make sense to specify more than one mapping for such an attribute.
The mapping can be specified in a resource or in the role, but only one of those should be active at the time.
Mapping conditions and strength can be used to selectively deactivate some mappings in more complicated cases.
But it still means that only one mapping is active at a time.

However, some attributes are multi-value.
In that case midPoint will merge the values from all the mappings.
In that case several roles may contribute to the final set of attribute values, as can the mapping in resource definition.
This is the usual case of attributes that specify privileges, such as permissions, authorization codes, access control list (ACL) entries and so on.

Merging of multi-value attributes is an easy way how to manage simple privileges in resources.
However, midPoint contains a whole sophisticated mechanism for managing _entitlements_ such as groups.
There is an entire chapter in this book dedicated to entitlement management.

NOTE: MidPoint is built on a principle of merging.
Assigned roles are merged together, that is merged with outbound mappings, entitlements are merged and so on.
MidPoint always adds, it never subtracts. E.g. there is no simple way how one role can "eliminate" a value given by another role.
If a role specifies that an account should have value A, that account will have value A. And that’s it.
It can also have values B and C given by other roles.
But A will always be there, no matter what other roles do (unless those roles are involved in some really dark magic).
This may seem quite limiting.
But it is sufficient for vast majority of cases.
It only needs a change in your way of thinking about privileges.
Do not think about removing a privilege.
Think about _not adding_ a privilege.
There are many ways how that can be achieved.
There is a role hierarchy, mappings can be conditional and whole assignments and inducements can be conditional too.
We are trying really hard to avoid concept of "removing" privileges, because that requires ordered processing.
E.g. if role X adds something and role Y removes it, the final result depends on the order in which such roles are processed.
This creates ambiguities, it limits parallelism and overall it is a huge complication.
Therefore we try to avoid it.
And so far we have been successful.

== Role Hierarchy

Ability to group privileges into roles is quite useful.
But it is still not good enough unless your access control policy is extremely simple.
Most practical policies require to place roles into roles, thus creating role hierarchy.

Let’s consider two work positions: clerk and supervisor.
Clerk has some basic set of privileges.
Supervisor can do everything that a clerk can do, but supervisor has some additional privileges.
A naive way would be to simply copy all the clerk’s privileges in supervisor’s role.
However, privileges are seldom static.
Access control policies tend to change and evolve as much as the environment changes.
It is likely that a clerk’s privileges will change.
In that case we will need to update the the supervisor’s role as well.
This would be a maintenance burden.
Now imagine hundreds or thousands of related roles that need constant maintenance.
Any person maintaining such a structure will need superhuman precision and patience to do that.

A more natural idea would be to include clerk’s role into a supervisor’s role.
If clerk’s privileges change, then also supervisor’s privileges are automatically updated.
Maintenance is much easier.
And that is the basic idea of role hierarchy.
Basic privileges are placed into low-level roles.
Low-level roles are combined to create a higher-level roles.
Then those roles are combined as well.
The process is repeated until there are all the roles that are needed for assignment to users.

image::07-06-role-hierarchy.png[Role hierarchy]

Creating role hierarchies in midPoint is quite easy.
A clever reader would already expect that this has something to do with inducements.
And clever reader would be absolutely right.
Role hierarchy is nothing more than a set of inducements between roles:

[source,xml]
----
<role oid="48d4ef98-20e3-46ab-cd78-548d38364a6b3">
    <name>Clerk</name>
    <!-- Privileges needed to do clerk’s work will be here. -->
</role>
----

[source,xml]
----
<role oid="86e58643-d5e7-36a8-04f6-38dc3754f04e">
    <name>Supervisor</name>
    <!-- Privileges that are unique to supervisor’s work will be here. -->
    <inducement>
        <!-- This "includes" all the clerk’s privileges in this role -->
        <targetRef oid="48d4ef98-20e3-46ab-cd78-548d38364a6b3" type="RoleType"/>
    </inducement>
</role>
----

The inducement includes `Clerk` role in `Supervisor` role.
When midPoint evaluates the `Supervisor` role, it will get all the inducements from both the `Supervisor` and `Clerk` roles.
This process is almost transparent, it works almost as if the clerk’s privileges were copied in the supervisor’s role.
All the constructions in all the inducements in both roles are processed.
Therefore supervisor will get all the accounts that a clerk would get, plus few extra privileges.

image::07-07-supervisor-clerk-inducement.png[Supervisor-clerk inducement]

Both `Clerk` and `Supervisor` roles are likely to have construction for the same account.
This is quite natural, as both clerk and supervisor would probably work with the same applications.
However, their privileges will be different.
This is where the merging mechanism becomes very useful.
When a supervisor role is processed then privileges of clerk are merged with privileges of supervisor:

[source,xml]
----
<role oid="48d4ef98-20e3-46ab-cd78-548d38364a6b3">
    <name>Clerk</name>
    <inducement>
        <construction>
             <!-- Record management system -->
             <resourceRef oid="84de003e-014f-2040-efbc-482e009ed2bcf"/>
             <kind>account</kind>
             <attribute>
                 <ref>ri:priv</ref>
                 <outbound>
                     <expression>
                         <value>read</value>
                         <value>create</value>
                     </expression>
                 </outbound>
             </attribute>
        </construction>
    </inducement>
</role>
----

[source,xml]
----
<role oid="86e58643-d5e7-36a8-04f6-38dc3754f04e">
    <name>Supervisor</name>
    <inducement>
        <construction>
             <!-- Record management system -->
             <resourceRef oid="84de003e-014f-2040-efbc-482e009ed2bcf"/>
             <kind>account</kind>
             <attribute>
                 <ref>ri:priv</ref>
                 <outbound>
                     <expression>
                         <value>approve</value>
                         <value>modify</value>
                         <value>delete</value>
                     </expression>
                 </outbound>
             </attribute>
        </construction>
    </inducement>
    <inducement>
        <targetRef oid="48d4ef98-20e3-46ab-cd78-548d38364a6b3" type="RoleType"/>
    </inducement>
</role>
----

When supervisor’s role is processed, midPoint figures out that those two `construction` statements are referring to the same account.
Therefore they will be merged together.
Supervisor will get an account that will have `priv` attribute set to values `read`, `create`, `approve`, `modify` and `delete`.

image::07-08-supervisor-clerk-inducement-constructions.png[Supervisor-clerk inducement with constructions]

NOTE: So far we have seen only inducement in the roles.
But what about assignment?
Assignment is indeed used in the roles, but it has different meaning.
Inducement means that role A has to be included in role B. But assignment means that role A has to be applied to role B. In that case role A is in fact a meta-role.
But more on that later.
For now it is good to remember a rule of the thumb: role hierarchy is always created by inducements.

== Role Universality

MidPoint roles are very useful kind of an animal, because they are used for almost everything in midPoint.
MidPoint role be used as:

* *Provisioning role:* The role can include constructions that control provisioning and deprovisioning of accounts.

* *Entitlement management:* The constructions can include specification of groups, resource-side roles, privileges and so on.

* *Internal authorization:* The roles give access to data in midPoint itself. E.g. a role can allow reading some user properties.
Authorizations in a role can also allow access to particular parts of midPoint user interface, remote network services and so on.

* *Policy specifications:* Roles (and especially meta-roles) are the places where important parts of policy management is specified.
Roles include policy rules that can apply segregation of duties (SoD) policies, ownership and approval policies and so on.

All those aspects can be combined together into a single role.
Therefore such role can specify everything that is needed for the role holder to live a complete digital life: access to systems (accounts), entitlements, access to midPoint itself (e.g. for self-service), apply policy constraints and so on.
Everything in one place.

Role universality may seem mundane and completely natural, but in fact it is quite unique and incredibly powerful idea.
As you will see later, roles can be driven through approval process, lifecycle management can be applied to role, roles can be subject to policies, role compliance can be evaluated and so on.
All of this applies to provisioning roles.
But the same mechanism can be applied also to roles that govern the administration of midPoint itself.
And even to meta-roles that specify high-level policies.
Which means that in a strange post-modern way midPoint can be applied to itself.
MidPoint can be its own manager.

NOTE: Surprisingly, role universality is quite an unique concept in the IDM field.
The common approach of older IDM systems is to separate provisioning roles, authorization roles, governance roles and so on.
Each of them was different and it was managed in a different way.
It was quite difficult to create a unified and consistent policy.
This is one of many aspects where midPoint provides a seemingly simple mechanism, but that mechanisms simplifies a lot of things and provides an elegant solution to a difficult problem.

== Role Hierarchy Structure

There are many way how a role hierarchy can be structured.
One way is to create all roles as "end user" roles that are supposed to be directly assigned to user.
The clerk-supervisor example above is that case.
But there are also other approaches that are often used.
For example, the low level roles are often modeled as _application roles_.
Those roles deal with access to a single application, but they are not meant to be assigned directly to users.
They are supposed to be abstract, to be the base "material" used to create other roles.
Those higher-level roles are often called _business roles_, as they reflect the needs of the business, such as specific job or responsibility in a business process.
Those roles are assigned to users.
However, those are just two of many conventions and recommendations on designing a role structure.
We will not dive deep into role modeling topics in this book.
There is a plenty of literature on that topic already.
We will rather focus on a technical implementation of role hierarchy in midPoint.

However, there are few cases that are frequent pain points in RBAC deployments.
The philosophy of midPoint is to make IDM deployment easier, therefore it is quite natural that midPoint tries to address those particular issues.

One of the big troubles are application roles.
There is usually a huge number of them and they need to be maintained manually.
It is usual practice that there is one application role for every privilege in the target system (resource), for every group for every organizational unit and so on.
Application roles duplicate the information that is already present on the resource side.
And as application roles are maintained manually, it is almost certain that this information will become inconsistent.
This approach is sometime even recommended as a best practice.
But the reality it is a maintenance nightmare.

This behavior is motivated by several factors.
But perhaps the strongest factor is that it was very difficult to set up the privileges in older (first generation) IDM systems.
Setup of an application role often required intimate knowledge of the entire IDM configuration as various tricks were used to implement entitlement management.
Heavy connector support and customization were often necessary to provide even the very basic entitlement management.
However, midPoint is different.
There is a clean concept of _construction_, which is designed in such a way that a system (resource) administrator can understand.
E.g. the construction refers to the native (non-mapped) names of resource attributes, it is referring to native object classes that are used on the resource, native identifiers and so on.
The construction is built to use the language of the target system (resource), not the language of midPoint.
Therefore there is a good chance that system administrators can set up constructions easily.
In addition to that, midPoint has a native support for entitlements such as groups and resource-side roles.
Those are designed to be easy to use in constructions.
Therefore there is very little need for application roles in midPoint.
Higher-level roles can contain the constructions directly.
Therefore the need for application roles in midPoint is significantly reduced.

However, application roles may still be needed and in some cases they may even be useful.
For example there may be a common combination of privileges that is always assigned together.
In that case it makes a lot of sense to create an application role.
There may still be a need for application roles if strong role lifecycle management is required.
Or application roles might be a legacy from a previous IDM system.
As always, the best recommendation would be to analyze the RBAC policies and to use pragmatic thinking.
Be careful about generic RBAC recommendations and be even more careful about recommendations that are meant for older IDM systems.
MidPoint is different.
Of course, midPoint can implement all those old fashioned RBAC models.
But it will be a pain to maintain.
MidPoint can do better.
Try to understand how midPoint works with the roles first.
And they apply those mechanisms to your RBAC policies.
You might be surprised how midPoint can simplify the implementation of the policies.

In case that application roles are still needed, you can consider to automate the management of those roles.
MidPoint synchronization mechanism is really powerful.
It can synchronize users and accounts, but it is designed to synchronize almost anything with anything.
Therefore it can be used to automatically create application roles from all the LDAP groups.
While this approach still have some drawbacks, it automates the most painful parts of application role’s maintenance.

There is yet another practice that is quite common, but mostly wrong.
Many IDM deployments create "login roles" or "default roles" for each application (resource).
Those roles are supposed to define basic properties of the account.
And in some cases they are supposed to keep account in existence when such account is unassigned.
While this practice is very common, it is complicated, messy and very difficult to maintain.
MidPoint was specifically designed tn such a way that this practice is not necessary in midPoint deployments.
Default account attributes are easy to set up by using resource definition.
And even the ability to keep unassigned account is directly supported in midPoint by using existence mapping, which will be described later.
Therefore such “login roles” are not needed at all in midPoint deployments and they are generally considered to be a bad practice.

== Assignment Gets Complicated

At the first sight, the concept of assignment may seem quite mundane, maybe even over-complicated.
But in fact it is a very powerful concept and it has been a crucial part of midPoint design from the very beginning.
Assignment is so much more that just a simple user-role connection:

* Assignments can have *validity period*.
This can be used to assign roles for a temporary period of time.
It can also be used to assign roles that will be activated in the future.

* Assignment have *administrative status* that can be used to manually disable or enable a particular assignment.
This can be used to manage exceptions from the policies or it can be very useful in emergency situations.

* Assignments can contain *parameters* that are used to support parametric roles (see above).

* Assignments are subject to policies, governance and compliance mechanisms.
Assignments have their lifecycle, they are subject to re-certification campaigns, there can be policy exception recorded for an assignment and so on.
But more on that in later chapters of this book.

For example, assignment validity period can be used to assign a role only for a temporary period:

[source,xml]
----
<user>
    <name>bob</name>
    ...
    <assignment>
        <!-- Deputy Cheerleader role -->
        <targetRef oid="0c87d8f8-c9a4-11e9-81b8-e7d43e9f9a2b" type="RoleType"/>
        <activation>
            <validTo>2019-12-31T23:59:59Z</validTo>
        </activation>
    </assignment>
</user>
----

As assignment and inducement are in fact the same data structure, similar approach can be used to disable parts of role hierarchy:

[source,xml]
----
<role>
    <name>Marketing Research Undersecretary</name>
    ...
    <indudement>...</indudement>
    <indudement>...</indudement>
    ...
    <indudement>
        <description>
            Employee access to the lab is disabled because the lab burned down
            during an ugly accident. Will be re-enabled when the lab is rebuilt.
        </description>
        <!-- Experimental Research Lab Access role -->
        <targetRef oid="e8ef819c-c9a4-11e9-80a8-1bddb446391e" type="RoleType"/>
        <activation>
            <administrativeStatus>disabled</administrativeStatus>
        </activation>
    </inducement>
</user>
----

Many types and variants of assignments can be combined in a single user.
Assignment validity periods may overlap, there may be disabled assignments and enabled assignments for the same role at the same time, there may be several assignments to the same role with various parameters and so on.
All reasonable combinations are supported, which allows to model very complicated schemes such as multi-affiliation, multiple employment contracts and so on.
Assignment is a crucial data structure and we will be dealing with it in almost every chapter in the book.

== Dynamic Roles

RBAC is a nice and elegant way how to create and maintain access control policies.
However, there is a serious danger: roles can be quite explosive.
The role structure can easily get out of control and the roles may start to multiply.
This is known as _role explosion_ and it is one of the nastiest drawbacks of access control system based on static roles.
It is not uncommon for an organization to have much more roles than it has users.
This creates a recurring maintenance nightmare.
Fortunately, midPoint has a very powerful support for dynamic roles that can significantly reduce or even completely eliminate the impact of role explosion.

To understand dynamic roles, we first need to understand what is wrong with static roles.
Many organizations have jobs that are very similar, they just differ is some small detail.
For example, all bank tellers are similar, the difference is just their branch office.
Similarly, all the assistant jobs are pretty much the same.
The difference is the department or section that they work for.
Therefore there is `Sales Assistant`, `Engineering Assistant`, `Logistics Assistant` - and a hundred or so similar roles.
Almost all the privileges in those roles are the same.
Of course, we can create an (abstract) role `Assistant` that will have all the common privileges.
But we still need those hundreds of specific assistant roles.
And then it gets even worse, because there may be `Senior Sales Assistant`, `Trainee Sales Assistant`, `Senior Engineering Assistant`, ...

The key to the role explosion is a realization that those "exploded" roles are created in a algorithmic way.
Maybe we do not need `Sales Assistant`, `Engineering Assistant` and `Logistics Assistant` roles at all.
Maybe we need just one `Assistant` role.
The organizational unit (sales, engineering or logistics) is just a parameter to that role.
Then the number of roles can be significantly reduced.
This is what we call _parametric roles_.

Parametric roles are not your ordinary garden-variety static roles that just contain a set of privileges.
Parametric roles need to be much smarter. E.g. the Assistant role need an algorithm, that takes the organization unit as an input and it outputs a privileges that are appropriate for that organizational unit.
This may be a simple expression that determines correct group name based on organizational unit name.
But it may also be quite a complex code that determines most efficient location of home directories and other resources based on office location.
There is no free lunch.
The algorithm that was used to generate the number of "exploded" roles will not magically disappear.
In case of parametric roles that algorithm needs to be placed in the role itself.
But it still may be much easier to maintain a couple of expression than to maintain thousands upon thousands of roles.

The usual problem with parametric roles is, quite obviously, the presence of the parameters.
The parameters cannot be stored with the role, as they are different for each assignment of the role.
The parameters also cannot be stored directly with the user, as the user may have the same role assigned with a different set of parameters.
Fortunately, midPoint was designed with this problem in mind and this was one of the big motivations to create a concept of _assignment_.
Assignment is the right place to store the parameters, as it is the data structure that associates user with a specific role.

ExAmPLE is a very progressive company.
Similarly to other corporations they have functional organizational structure.
But their employees are also organized in teams.
Each team can have a manager and ordinary members.
The team membership is represented by custom attributes in LDAP server.
Each user has two custom multi-value attributes: `exampleTeamMember` and `exampleTeamManager`.
Both attributes expect team name as their value.

The naïve way to handle this would be to create two roles for each team.
But there are hundreds of team and that would be a maintenance nightmare.
A smarter solution is to use parametric roles.
There will be two roles only: `Team Member` and `Team Manager`.
Those roles will take custom property `teamName` as parameter.
But where does this property comes from?
It comes from assignment extension.
Each time the team role is assigned there needs to be a parameter in the assignment:

[source,xml]
----
<user>
    <name>alice</name>
    ...
    <assignment>
        <extension>
            <exmpl:teamName>x-force</exmpl:teamName>
        </extension>
        <!-- Team Manager role -->
        <targetRef oid="aaa6cde4-0471-11e9-9b50-c743da469067" type="RoleType"/>
    </assignment>
</user>
----

This is the first part of the solution.
The second part are the roles.
The roles needs to be a bit smarter to use the `teamName` parameter:

[source,xml]
----
<role oid="aaa6cde4-0471-11e9-9b50-c743da469067">
    <name>Team Manager</name>
    ...
    <inducement>
        <construction>
             <!-- OpenLDAP resource -->
             <resourceRef oid="8a83b1a4-be18-11e6-ae84-7301fdab1d7c"/>
             <kind>account</kind>
             <attribute>
                 <ref>ri:exampleTeamManager</ref>
                 <outbound>
                     <expression>
                         <path>$assignment/extension/teamName</path>
                     </expression>
                 </outbound>
             </attribute>
        </construction>
    </inducement>
</user>
----

Resulting LDAP account looks like this:

[source]
----
dn: uid=alice,ou=people,dc=example,dc=com
objectclass: inetOrgPerson
...
exampleTeamManager: x-force
...
----

This setup is illustrated in the following diagram:

image::07-09-user-parametric-role.png[Parametric role assignment]

This is the basic mechanism of parametric roles.
It is incredibly powerful mechanism.
Unfortunately, current implementation of parametric roles in midPoint is quite limited.
While midPoint was designed with parametric roles in mind, the implementation is not yet finished.
Therefore support for parametric roles is quite limited.
MidPoint core supports parametric roles quite well.
Assignment parameters and mappings should work perfectly.
However, the support for assignment parameters in midPoint user interface is very limited.
In fact the production-quality support is limited only to the couple of hardcoded parameters (`orgRef` and `tenantRef`) and even that leaves a lot to be desired.
While we would like to improve support for parametric roles in midPoint, we have to listen to what midPoint subscribers are saying.
Our development priorities are influenced by midPoint platform subscribers.
So far platform subscribers prioritized other features and therefore there was not sufficient funding to completely finish user interface support for parametric roles.

NOTE: Roles may also explode due to other reasons.
Application roles that were mentioned above may significantly contribute to role explosion.
Also attempts to "atomize" the low-level roles as an attempt to create enough "material" to compose higher-level roles may lead to explosion.
MidPoint has some mechanism that limit those effects.
But perhaps the best approach for those cases could be summarized as "do not overdo it".

== Metaroles

MidPoint roles are usually applied to users.
But midPoint roles are universal.
The roles can be applied to almost any midPoint object.
Roles can be applied to users, organizations, services and even to roles themselves.

Simply speaking, meta-roles are roles applied to other roles.
Ordinary role applies its characteristics to a user.
Meta-role applies its characteristics to another role.
This is perfectly possible in midPoint, as role can be applied to almost any midPoint object.
Then why not apply a role to a another role?
This may seem like a pretty useless exercise, but the truth is that meta-roles are tremendously useful.

History is repeating, they say.
And the fact is that repetition is a daily bread in almost all IDM deployments. E.g. many business roles have something in common.
For example the business roles have similar approval process.
There may be role classes that have similar exclusion policies that are part of global segregation of duties (SoD) policy.
There are roles that are tied to entitlements in a systematic way and so on.
Roles, organizational units, services and other role-like objects tend to be quite similar.
Therefore applying meta-roles to them can be very useful.

So far all the roles that we have seen were composed exclusively from inducements.
And that made perfect sense, as all those things that were in the inducement did not apply to the role itself.
Those things applied to users that the role was assigned to.
But in this case we want to apply meta-role to a role.
The effects of a meta-role should apply to the role, not to the user.
Therefore assignment is used instead of inducement:

[source,xml]
----
<role oid="6924fb9c-a184-11e9-840e-2feb476335f4">
    <name>Account Manager</name>
    <description>
        This is business role that corresponds to account manager job.
    </description>
    <assignment>
        <!-- Metarole assignment -->
        <targetRef oid=”a3065910-a183-11e9-835c-0b6edc3d44c3” type=”RoleType”/>
    </assignment>
    <inducement>
        <!--
             Privileges specific to account manager.
        -->
    </inducement>
</role>
----

[source,xml]
----
<role oid="a3065910-a183-11e9-835c-0b6edc3d44c3">
    <name>Business metarole</name>
    <inducement>
        <!--
            Policies and constructions that should be applied to all
            business roles.
        -->
    </inducement>
</role>
----

This may seem similar to a role hierarchy.
But it is a completely different animal.
The crucial difference is that the meta-role is applied to the role and not to the user.
The inducements in the meta-role often contain policies such as approval policy.
Or construction clauses that create groups or organizational units.
We usually do not want to create a group for each user.
But we often want to create a group for a role.
That’s what meta-role can do.

TIP: Meta-roles are one of the stranger concepts of midPoint, but it goes well with midPoint philosophy.
Meta-roles are roles that are applied to themselves.
This is a reuse of a an existing mechanism to create something new.
This is very typical for midPoint.
We always try to reuse an existing mechanism instead of reinventing a new one.
And sometimes the result is quite unexpected and surprising.
When we have designed the RBAC system for midPoint, we haven’t thought about meta-roles at all.
The meta-roles just appeared as a consequence of the design, a consequence that was absolutely unexpected.
But we have quickly realized the potential that meta-roles have and we have put them to a full use.

A clever reader would probably notice that meta-roles can be used to set up different types of roles.
We could have meta-role for application role, business role and so on.
And clever reader, as always, would be right.
However, there are few bits still missing here to create a full-featured type system.
And those missing bits are implemented in a form of _archetypes_.
Simply speaking, archetypes are meta-roles with some optimizations and improved user experience.
But more on that later.

It may be difficult to understand the concept of meta-roles from such a short and very abstract description.
But do not worry.
As meta-roles are often used in midPoint, we will get back to the meta-roles on several occasions.
Meta-roles often allow to simplify complex problems by creating a very elegant solutions.
But for now it is enough to remember that roles can be applied to almost anything in midPoint, including themselves.

== RBAC, ABAC And The Wildlife

This section is where we will get all thoughtful and philosophical.
We will also throw some dirt on almost every access control model in existence.
Therefore people that are bored with philosophical questions and people that maintain dogmatic believes about IAM mechanisms should skip this section.
On the other hand, open-minded people are quite likely to enjoy it.

Role-based Access Control (RBAC) is just one of many access control models.
There many variants of RBAC and there are also other access control models that are based on a completely different paradigm.
One such popular model is Attribute-Based Access Control (ABAC).
ABAC is based on a an idea that access to the systems can be determined dynamically just based on "attributes".
Simply speaking we can imagine ABAC as a one big algorithm that takes “attributes” as an input and decides whether access should be allowed or denied.

ABAC is very popular in the access management (AM) community because of its simplicity.
And it all makes much sense as it is much simpler and faster to evaluate one expression than to sift through a mountain of roles.
The problem with ABAC is manageability.
ABAC assumes that all access control decisions could be based on algorithms and that they can be made anytime a decision is needed.
However, that is almost never the case in larger practical deployments.

Many professionals responsible for identity management dream about complete automation of access control.
It would be a marvel if an IDM system could automatically determine the privileges of every person simply based on the organizational unit and work responsibilities of that person.
It would be perfect to get that information from an HR system, process it through a set of algorithms and automatically provision correct privileges to everybody.
That is a very nice dream.
But reality has a different idea.
Such automated approach never really works in practice.

First problem is at the very start: HR data are almost never correct.
There is very little motivation for the HR data to be completely correct.
It is not a big issues if someone has a wrong job code or organizational unit code in the HR system.
The business goes on, the salary is paid, everybody is happy.
There is no really efficient feedback loop that would force corrections in HR data.
Until the IDM system is deployed, that is.
But it takes years or decades for a typical company to get to deployment of IDM system.
At that point the HR data are beyond repair.
The corrections that need to be done in the HR system are substantial.
Even in small organizations it is very difficult to correct HR data manually.
Bigger deployments absolutely require proper tooling to do that job.
But even with good tooling it can take a lot of time.
Many IDM deployments were significantly delayed or even canceled because of data quality problems.
This method does not work very well.

The fundamental problem here is in the overall approach.
IDM system should not fail when the input data are wrong.
There should be procedures how to correct those data.
And the IDM deployment should not be delayed because of wrong input data.
That would be like refusing to use your reading glasses because the text you are reading is wrong.
IDM systems are essential tools that help you to clean up the data.
The IDM system should be deployed and it should be used to manage data quality on day-to-day basis.
It is naive to think that once the data are cleaned up they will stay clean.
The processes that lead to data errors will continue, therefore data errors will appear all the time.
The crucial insight is to accept that there will be data errors and to design the mechanisms to detect and correct them.

There are many manual and ad-hoc decisions that need to be made in practical IDM deployments.
And not just during the deployment.
Many ad-hoc decisions must be made during routine operation.
Privileges need to be assigned manually to compensate for missing input data.
Privileges need to be corrected, input data need to be temporarily overridden, policy exceptions has to be made.
There are many things that need to do manually.
Such decisions are made almost on day-to-day basis.
For ABAC and similar systems this would mean that a policy needs to be updated on a day-to-day basis.
And ABAC is not designed for that.

This leads to another big problem of ABAC and similar "flexible" access control models.
Even if HR are data are correct, the data usually do not provide all the information needed to completely provision the user with privileges.
The HR data are often limited to organizational unit and formal code of the work position.
However, this is often miles away from the job that user really does.
The usual solution to this problem is that the user requests the privileges that are needed to to a job.
Such request is then routed through appropriate approval process.
And that _request_ is a big problem for ABAC. What should the user request to get the privileges?
Should the user request a change in ABAC policy?
That would not be practical.
Should the user request a new value for an attribute?
Which attribute?
And what value that should be?
Can be somehow create a catalog of the things that a user can request?
Once again, ABAC is not designed for this.
But all those problems are very easy to solve in RBAC. User is expected to request a role.
And it is quite easy to create a role catalog.
But as ABAC does not have roles, there is nothing that a user can get a grip on.
There is no "handle" that would allow the user to make sense from the ABAC policies.

This is all a consequence of yet another ABAC problem.
While ABAC policy may be easy to set up, it is quite difficult to analyze and maintain.
Which users are affected by this particular policy statement?
How many users will be affected if I make this change to ABAC policy?
ABAC systems would need a complex simulation algorithms to answer those questions.
However, it is all quite trivial in RBAC. Policies are encapsulated into roles.
Therefore the users that have those roles are affected.
The roles also divide the policy to a smaller, manageable pieces.
Each of the roles can have its own state and lifecycle.
Therefore it is easy to work with two versions of the same role at the same time.
Old version is still assigned to some users, but we are deprecating that and slowly migrating to a new version.
Such continuous processes are difficult to do in ABAC.

And there is still one crucial problem when ABAC is used in provisioning scenarios.
ABAC policies often benefit from the fact that complete data about the user accessing the system are available when the access control decision is made.
The crucial part of that data is called _context_.
This includes data such as time of day, network location of the user, recent events related to the user, real-time estimate of the risk and so on.
However, such data are simply not available in provisioning scenarios.
Accounts are usually provisioned long before the first access to the account is made.
Therefore many of the advantages of ABAC are useless in identity management scenarios that rely on provisioning.

However, ABAC is not a complete failure.
ABAC is very useful in customer-oriented identity and access management (CIAM).
Customer identities are usually "lightweight" and the policies are simple.
But when there is a need to manage employees, teachers, contractors and similar "heavyweight" identities then ABAC almost always fails.

The fact that ABAC fails in complex practical IDM deployments does not mean that RBAC is ideal.
Quite the contrary.
RBAC has problems of its own and the applicability of pure RBAC in practical IDM deployments is very limited.
Many of the problems of RBAC model motivated engineers to develop ABAC and similar models.
In fact, the "algorithmic" idea of ABAC is not entirely bad.
Only if we had a way how to combine ABAC and RBAC ... Oh, but there is a way!
We did it already.

MidPoint combines RBAC and ABAC by putting expressions into roles.
We have seen that already.
When role is assigned, the expressions in the role gets evaluated.
And there can be any complex algorithm in the expression, even a complete ABAC policy.
At least in theory.
MidPoint expressions do not make access control decisions, because it is not the job of an IDM system to make such decisions.
IDM system should set up the account.
It provides the "material" for an authorization system to make a correct decisions.
Therefore midPoint goes as close to ABAC as a provisioning system can go.
In an extreme case the entire ABAC policy can be implemented in outbound expressions in resource definition.
But there is a good reason nobody does that.

Dividing the policy into smaller parts brings substantial advantage.
Therefore many midPoint deployments are very RBAC-like.
There are many roles and rich role hierarchies.
Role expressions are used in moderation.
But there are also deployments that are using parametric roles and role expressions extensively.
In such cases there is a smaller number of roles, almost no role hierarchy, but the roles are smarter.
Those are more ABAC-like deployments.
But roles are still there.
The roles act as "handles" for users to understand the policies, to give names to relevant parts of the policy.
This combined approach works surprisingly well.

Of course, this idea is not new.
Many RBAC-like systems use some kind of "smart" behavior inside the roles.
However, so far we haven’t seen anything as comprehensive as midPoint role-based access control model.
Therefore we had to invent an impressive marketing name for our creation.
Due to a momentary lapse of imagination we dubbed it Advanced Hybrid RBAC.
But whatever you choose to call it, the fact is that this approach is very useful in practice.
It can transform apparent chaos into something that can be efficiently managed.
